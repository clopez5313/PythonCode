* input() obtains data from the keyboard.
* if expr:
    xxxx
    xxxx
  elif expr:
    xxxx
    xxxx
  else:
    xxxx
  (SYNTAX FOR CONDITIONALS)
* try:
    xxxx
    xxxx
  except:
    xxxx
    xxxx
  (SYNTAX FOR TRY/CATCH)
* max() returns the biggest element in a list, min() returns the smallest.
* len() returns the number of elements in the object.
* x = int(x), x = float(x) convert the variable into the assigned type.
* 'math' and 'random' need to be imported before used.
* def functionName():
    xxxx
    xxxx
  (SYNTAX TO DEFINE NEW FUNCTIONS)
* Function definitions don't generate any output. Statements within them aren't executed until the function is called.
* while expr:
    xxxx
    xxxx
  (SYNTAX FOR INFINITE LOOPS)
* for x in obj:
    xxxx
    xxxx
  (SYNTAX FOR FINITE LOOPS)
* 'continue' is used to end the current iteration without exiting the while loop. It proceeds with the next iteration.
* word[i:j] retrieves the characters between i and j-1.
* dir() can be used to list the available methods of an object.
* strip() is used to remove the blank spaces at the beginning and the end of a string. rstrip() removes the spaces on the right side of a string.
* %d, %g, and %s can be used to format strings.
 'In %d I got a %g grade on %s.' % (2010,9.5,'math class')
* open(file location) is used to open a file. If it succeeds, a file handle is returned.
* If the size of the file is small enough, it can be read in one string using read().
* find() looks for occurrences of a string within another string. Returns the position of the string or -1 if it wasn't found.
* Protecting the open() call with a Try/Except is a good practice.
* To write a file, it has to be opened like this: open(file location, w). If the file already exists, the contents will be deleted and replaced with
  the new text.
* write() puts the data in the file and returns the number of characters written.
* close() needs to be used when writing files.
* A list is a sequence of elements, which can be of any type. The list can have elements of many types.
* Unlike strings, lists are mutable.
* append() adds an element at the end of a list.
* extend(list) takes a list as an argument and adds it at the end of the list that calls the method.
* sort() arranges the elements in the list from high to low.
* pop(index) can be used to delete elements in a list. It returns the removed element. If an index is not given, it deletes and returns the last
  element of the list.
* If the element is not needed, then del list[index] can be used instead.
* remove(element) can be used if the element is known but not the index.
* To remove more than one element at the same time, 'del' with a slice index can be used.
* sum() only works on lists when the elements are numbers.
* To convert from a string to a list (array) of characters, list(string) can be used.
* split() is used to break a string into words. It can use an optional argument called delimiter that specifies which characters are used as words
  boundaries.
* join(list) takes a list of strings to concatenate the elements of that list.
* 'is' can be used to determine if two variables refer to the same object.
* When a list is passed as argument to a function, the function gets a reference to the list. If the function modifies a list parameter, the caller
  of the function sees the change.
* append() modifies a list, while the '+' operator creates a new list.
* A dictionary is a more general type of list. Their indices can be almost of any type.
* Dictionaries can be seen as mappings between a set of keys (indices) and a set of values.
* Square brackets can be used to add items to a dictionary: dict[key]=value
* The order of items in a dictionary is unpredictable. That's why keys are used to look for corresponding values.
* On dictionaries, len() returns the number of key-value pairs.
* The 'in' operator tells whether something appears as key in the dictionary.
* To see whether something appears as a value, the values() method needs to be used. It returns an object that can be converted to list, and then the
  'in' operator can be used again.
* get(key,value) checks if the key appears in the dictionary. If it does, returns the corresponding value, otherwise returns the default value.
* A tuple is a sequence of values. The values stored in a tuple can be of any type and they are indexed by integers. Tuples are immutable though.
* Create a tuple with a single element: t = (element,)
* Create an empty tuple: t = tuple()
* If the argument in tuple(object) is a sequence (string, list, or another tuple), the result of the call is a tuple with the elements of the sequence.
* Comparison on tuples: compares the elements of each sequence in ascending order until it finds elements that differ. Subsequent elements are not
  considered.
* Dictionaries have a method called items() that return a list of tuples, where each tuple is a key-value pair.
